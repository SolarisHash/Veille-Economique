#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Mots-cl√©s sp√©cialis√©s pour PME - Version am√©lior√©e et r√©aliste
Simple, efficace, test√© sur le terrain
"""

from typing import Dict, List


class MotsClesPME:
    """Mots-cl√©s optimis√©s pour la r√©alit√© des PME fran√ßaises"""
    
    def __init__(self):
        """Mots-cl√©s test√©s et valid√©s pour les PME"""
        
        # ‚úÖ MOTS-CL√âS PME R√âALISTES (bas√©s sur le vrai langage PME)
        self.mots_cles_pme = {
            
            # üéØ RECRUTEMENTS PME (langage r√©el)
            'recrutements': {
                'essentiels': [
                    'cherche', 'recherche', 'recrute', 'embauche',
                    'poste √† pourvoir', 'nous recherchons', 'rejoindre notre √©quipe'
                ],
                'pme_specifiques': [
                    'cherche apprenti', 'forme un apprenti', 'accueille stagiaire',
                    'recherche vendeur', 'recherche vendeuse', 'cherche employ√©',
                    'besoin urgentement', 'poste disponible imm√©diatement'
                ],
                'contexte_local': [
                    'emploi local', 'travail proche', 'temps partiel accept√©',
                    'd√©butant accept√©', 'avec exp√©rience souhait√©e'
                ]
            },
            
            # üè™ √âV√âNEMENTS PME (r√©alit√© terrain)
            'evenements': {
                'essentiels': [
                    'ouverture', 'inauguration', 'nouveau magasin',
                    'porte ouverte', 'portes ouvertes', 'venez d√©couvrir'
                ],
                'pme_specifiques': [
                    'nouveaux locaux', 'd√©m√©nage', 'agrandit',
                    'f√™te ses', 'anniversaire', 'ann√©es d\'existence',
                    'soldes', 'promotion', 'op√©ration sp√©ciale'
                ],
                'saisonniers': [
                    'ouvert dimanche', 'horaires √©tendus', 'nocturne',
                    'march√© de no√´l', 'braderie', 'vide-grenier'
                ]
            },
            
            # üí° INNOVATIONS PME (adapt√©es √† la r√©alit√©)
            'innovations': {
                'essentiels': [
                    'nouveau service', 'nouvelle prestation', 'nouveaut√©',
                    'am√©liore', 'modernise', 'r√©nove'
                ],
                'pme_specifiques': [
                    'installe', '√©quipe de', 'investit dans',
                    'nouvelle machine', 'nouvel outil', 'se digitalise',
                    'livraison maintenant', 'commande en ligne', 'click and collect'
                ],
                'tendances_actuelles': [
                    '√©cologique', 'bio', 'local', 'circuit court',
                    'fait maison', 'artisanal', 'personnalis√©'
                ]
            },
            
            # üè¢ VIE ENTREPRISE PME (d√©veloppement r√©aliste)
            'vie_entreprise': {
                'essentiels': [
                    'd√©veloppe', 'grandit', 'expansion', 'croissance',
                    'partenariat', 'collaboration', 'association'
                ],
                'pme_specifiques': [
                    'reprend l\'entreprise', 'c√®de son entreprise',
                    'transmission', 'rachat', 'fusion',
                    'ouvre une succursale', 'second magasin'
                ],
                'geographiques': [
                    'implantation', 'installation', 's\'installe √†',
                    'rayonne sur', 'dessert maintenant', 'zone de chalandise'
                ]
            }
        }
        
        # üè≠ MOTS-CL√âS PAR SECTEUR PME (les plus courants)
        self.secteurs_pme = {
            'commerce': [
                'magasin', 'boutique', 'commerce', 'vente',
                'client√®le', 'service client', 'conseil'
            ],
            'restauration': [
                'restaurant', 'brasserie', 'caf√©', 'bar',
                'plat du jour', 'menu', 'r√©servation', 'terrasse'
            ],
            'artisanat': [
                'artisan', 'fait main', 'sur mesure',
                'r√©paration', 'cr√©ation', 'atelier'
            ],
            'services': [
                '√† domicile', 'sur site', 'intervention',
                'devis gratuit', 'urgence', '7j/7'
            ],
            'sante': [
                'cabinet', 'consultation', 'soins',
                'rendez-vous', 'urgence', 'garde'
            ]
        }
        
        # ‚ùå MOTS √Ä √âVITER (faux positifs courants)
        self.mots_a_eviter = [
            'd√©finition', 'dictionnaire', 'traduction',
            'cours de', 'formation √†', 'apprendre',
            'wikip√©dia', 'forum', 'question'
        ]
    
    def obtenir_mots_cles_adaptes(self, thematique: str, secteur: str = '') -> List[str]:
        """Obtient les mots-cl√©s adapt√©s √† une th√©matique et un secteur"""
        
        mots_finaux = []
        
        # 1. Mots-cl√©s de base de la th√©matique
        if thematique in self.mots_cles_pme:
            theme_data = self.mots_cles_pme[thematique]
            
            # Essentiels (toujours inclus)
            mots_finaux.extend(theme_data.get('essentiels', []))
            
            # PME sp√©cifiques (priorit√©)
            mots_finaux.extend(theme_data.get('pme_specifiques', []))
            
            # Contextuels (bonus)
            mots_finaux.extend(theme_data.get('contexte_local', [])[:3])
        
        # 2. Adaptation par secteur
        secteur_simplifie = self._detecter_secteur_principal(secteur)
        if secteur_simplifie in self.secteurs_pme:
            mots_secteur = self.secteurs_pme[secteur_simplifie][:4]  # Max 4
            mots_finaux.extend(mots_secteur)
        
        # 3. Nettoyage et limitation
        mots_uniques = list(set(mots_finaux))  # D√©duplication
        
        return mots_uniques[:15]  # Max 15 mots-cl√©s par recherche
    
    def _detecter_secteur_principal(self, secteur_naf: str) -> str:
        """D√©tecte le secteur principal depuis le libell√© NAF"""
        
        if not secteur_naf:
            return ''
        
        secteur_lower = secteur_naf.lower()
        
        # D√©tection par mots-cl√©s dans le secteur NAF
        if any(mot in secteur_lower for mot in ['commerce', 'vente', 'magasin']):
            return 'commerce'
        elif any(mot in secteur_lower for mot in ['restaurant', 'caf√©', 'bar', 'alimentation']):
            return 'restauration'
        elif any(mot in secteur_lower for mot in ['artisan', 'fabrication', 'r√©paration']):
            return 'artisanat'
        elif any(mot in secteur_lower for mot in ['service', 'conseil', 'maintenance']):
            return 'services'
        elif any(mot in secteur_lower for mot in ['sant√©', 'm√©dical', 'soin']):
            return 'sante'
        
        return 'general'
    
    def construire_requete_optimisee(self, nom_entreprise: str, commune: str, 
                                   thematique: str, secteur: str = '') -> str:
        """Construit une requ√™te optimis√©e avec les bons mots-cl√©s"""
        
        # Mots-cl√©s adapt√©s
        mots_cles = self.obtenir_mots_cles_adaptes(thematique, secteur)
        
        # S√©lection des 2-3 meilleurs mots-cl√©s
        mots_prioritaires = mots_cles[:3]
        
        # Construction de la requ√™te intelligente
        if len(nom_entreprise) < 30:  # Nom pas trop long
            requete = f'"{nom_entreprise}" {commune} {" ".join(mots_prioritaires[:2])}'
        else:
            # Nom long : utiliser mots-cl√©s principaux
            mots_entreprise = nom_entreprise.split()[:3]
            requete = f'{" ".join(mots_entreprise)} {commune} {mots_prioritaires[0]}'
        
        return requete
    
    def valider_pertinence_resultat(self, resultat: Dict, thematique: str) -> float:
        """Valide la pertinence d'un r√©sultat selon les mots-cl√©s PME"""
        
        titre = resultat.get('titre', '').lower()
        description = resultat.get('description', '').lower()
        texte_complet = f"{titre} {description}"
        
        # 1. V√©rification mots √† √©viter (exclusion)
        for mot_eviter in self.mots_a_eviter:
            if mot_eviter in texte_complet:
                return 0.0  # Exclusion imm√©diate
        
        # 2. Comptage mots-cl√©s pertinents
        mots_cles_theme = self.obtenir_mots_cles_adaptes(thematique)
        
        mots_trouves = 0
        mots_essentiels_trouves = 0
        
        for mot_cle in mots_cles_theme:
            if mot_cle.lower() in texte_complet:
                mots_trouves += 1
                
                # Bonus pour mots essentiels
                if thematique in self.mots_cles_pme:
                    essentiels = self.mots_cles_pme[thematique].get('essentiels', [])
                    if mot_cle in essentiels:
                        mots_essentiels_trouves += 1
        
        # 3. Calcul du score
        if mots_trouves == 0:
            return 0.0
        
        score_base = min(mots_trouves * 0.2, 0.8)
        bonus_essentiels = mots_essentiels_trouves * 0.1
        
        return min(score_base + bonus_essentiels, 1.0)


# INT√âGRATION DANS VOTRE SYST√àME
def integrer_mots_cles_pme():
    """Comment int√©grer les mots-cl√©s PME dans votre syst√®me"""
    
    code_integration = '''
# Dans votre recherche_web.py ou analyseur_thematiques.py :

from mots_cles_pme import MotsClesPME

class RechercheWeb:
    def __init__(self, periode_recherche):
        # Votre code existant...
        self.mots_cles_pme = MotsClesPME()  # ‚Üê AJOUT
    
    def construire_requetes_pme_territoriales(self, entreprise: Dict, thematique: str) -> List[str]:
        """Version am√©lior√©e avec mots-cl√©s PME optimis√©s"""
        
        nom = entreprise.get('nom', '')
        commune = entreprise.get('commune', '')
        secteur = entreprise.get('secteur_naf', '')
        
        # ‚úÖ NOUVELLE requ√™te optimis√©e PME
        requete_optimisee = self.mots_cles_pme.construire_requete_optimisee(
            nom, commune, thematique, secteur
        )
        
        # Vos autres requ√™tes existantes...
        requetes = [requete_optimisee]
        
        return requetes

class AnalyseurThematiques:
    def __init__(self, thematiques_config):
        # Votre code existant...
        self.mots_cles_pme = MotsClesPME()  # ‚Üê AJOUT
    
    def _valider_pertinence_resultat(self, resultat: Dict, thematique: str) -> float:
        """Validation am√©lior√©e avec mots-cl√©s PME"""
        
        # ‚úÖ NOUVELLE validation PME
        score_pme = self.mots_cles_pme.valider_pertinence_resultat(resultat, thematique)
        
        # Combiner avec votre validation existante si vous en avez une
        # score_final = (score_pme + votre_score_existant) / 2
        
        return score_pme
'''
    
    return code_integration


if __name__ == "__main__":
    # Test des mots-cl√©s PME
    mots_cles = MotsClesPME()
    
    print("üß™ TEST MOTS-CL√âS PME")
    print("="*40)
    
    # Test 1: Mots-cl√©s par th√©matique
    for thematique in ['recrutements', 'evenements', 'innovations']:
        mots = mots_cles.obtenir_mots_cles_adaptes(thematique, 'commerce de d√©tail')
        print(f"\n{thematique.upper()}: {len(mots)} mots-cl√©s")
        print(f"   {', '.join(mots[:8])}...")
    
    # Test 2: Requ√™te optimis√©e
    print(f"\nüéØ REQU√äTE OPTIMIS√âE:")
    requete = mots_cles.construire_requete_optimisee(
        "Boulangerie Martin", "Bussy-Saint-Georges", "recrutements", "boulangerie"
    )
    print(f"   {requete}")
    
    # Test 3: Validation
    print(f"\n‚úÖ TEST VALIDATION:")
    resultat_test = {
        'titre': 'Boulangerie Martin cherche apprenti √† Bussy-Saint-Georges',
        'description': 'La boulangerie recherche un apprenti motiv√© pour rejoindre notre √©quipe'
    }
    score = mots_cles.valider_pertinence_resultat(resultat_test, 'recrutements')
    print(f"   Score de pertinence: {score:.2f}")
    
    print(f"\nüìã CODE D'INT√âGRATION:")
    print("="*40)
    print(integrer_mots_cles_pme())